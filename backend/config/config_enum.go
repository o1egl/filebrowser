// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package config

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strings"
)

const (
	// LogFormatText is a LogFormat of type text.
	LogFormatText LogFormat = "text"
	// LogFormatJson is a LogFormat of type json.
	LogFormatJson LogFormat = "json"
)

var ErrInvalidLogFormat = fmt.Errorf("not a valid LogFormat, try [%s]", strings.Join(_LogFormatNames, ", "))

var _LogFormatNames = []string{
	string(LogFormatText),
	string(LogFormatJson),
}

// LogFormatNames returns a list of possible string values of LogFormat.
func LogFormatNames() []string {
	tmp := make([]string, len(_LogFormatNames))
	copy(tmp, _LogFormatNames)
	return tmp
}

// String implements the Stringer interface.
func (x LogFormat) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LogFormat) IsValid() bool {
	_, err := ParseLogFormat(string(x))
	return err == nil
}

var _LogFormatValue = map[string]LogFormat{
	"text": LogFormatText,
	"json": LogFormatJson,
}

// ParseLogFormat attempts to convert a string to a LogFormat.
func ParseLogFormat(name string) (LogFormat, error) {
	if x, ok := _LogFormatValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _LogFormatValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return LogFormat(""), fmt.Errorf("%s is %w", name, ErrInvalidLogFormat)
}

// MarshalText implements the text marshaller method.
func (x LogFormat) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LogFormat) UnmarshalText(text []byte) error {
	tmp, err := ParseLogFormat(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errLogFormatNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *LogFormat) Scan(value interface{}) (err error) {
	if value == nil {
		*x = LogFormat("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseLogFormat(v)
	case []byte:
		*x, err = ParseLogFormat(string(v))
	case LogFormat:
		*x = v
	case *LogFormat:
		if v == nil {
			return errLogFormatNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errLogFormatNilPtr
		}
		*x, err = ParseLogFormat(*v)
	default:
		return errors.New("invalid type for LogFormat")
	}

	return
}

// Value implements the driver Valuer interface.
func (x LogFormat) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// LogLevelDebug is a LogLevel of type debug.
	LogLevelDebug LogLevel = "debug"
	// LogLevelInfo is a LogLevel of type info.
	LogLevelInfo LogLevel = "info"
	// LogLevelWarn is a LogLevel of type warn.
	LogLevelWarn LogLevel = "warn"
	// LogLevelError is a LogLevel of type error.
	LogLevelError LogLevel = "error"
)

var ErrInvalidLogLevel = fmt.Errorf("not a valid LogLevel, try [%s]", strings.Join(_LogLevelNames, ", "))

var _LogLevelNames = []string{
	string(LogLevelDebug),
	string(LogLevelInfo),
	string(LogLevelWarn),
	string(LogLevelError),
}

// LogLevelNames returns a list of possible string values of LogLevel.
func LogLevelNames() []string {
	tmp := make([]string, len(_LogLevelNames))
	copy(tmp, _LogLevelNames)
	return tmp
}

// String implements the Stringer interface.
func (x LogLevel) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LogLevel) IsValid() bool {
	_, err := ParseLogLevel(string(x))
	return err == nil
}

var _LogLevelValue = map[string]LogLevel{
	"debug": LogLevelDebug,
	"info":  LogLevelInfo,
	"warn":  LogLevelWarn,
	"error": LogLevelError,
}

// ParseLogLevel attempts to convert a string to a LogLevel.
func ParseLogLevel(name string) (LogLevel, error) {
	if x, ok := _LogLevelValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _LogLevelValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return LogLevel(""), fmt.Errorf("%s is %w", name, ErrInvalidLogLevel)
}

// MarshalText implements the text marshaller method.
func (x LogLevel) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LogLevel) UnmarshalText(text []byte) error {
	tmp, err := ParseLogLevel(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errLogLevelNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *LogLevel) Scan(value interface{}) (err error) {
	if value == nil {
		*x = LogLevel("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseLogLevel(v)
	case []byte:
		*x, err = ParseLogLevel(string(v))
	case LogLevel:
		*x = v
	case *LogLevel:
		if v == nil {
			return errLogLevelNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errLogLevelNilPtr
		}
		*x, err = ParseLogLevel(*v)
	default:
		return errors.New("invalid type for LogLevel")
	}

	return
}

// Value implements the driver Valuer interface.
func (x LogLevel) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// LogOutputStdout is a LogOutput of type stdout.
	LogOutputStdout LogOutput = "stdout"
	// LogOutputStderr is a LogOutput of type stderr.
	LogOutputStderr LogOutput = "stderr"
)

var ErrInvalidLogOutput = fmt.Errorf("not a valid LogOutput, try [%s]", strings.Join(_LogOutputNames, ", "))

var _LogOutputNames = []string{
	string(LogOutputStdout),
	string(LogOutputStderr),
}

// LogOutputNames returns a list of possible string values of LogOutput.
func LogOutputNames() []string {
	tmp := make([]string, len(_LogOutputNames))
	copy(tmp, _LogOutputNames)
	return tmp
}

// String implements the Stringer interface.
func (x LogOutput) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LogOutput) IsValid() bool {
	_, err := ParseLogOutput(string(x))
	return err == nil
}

var _LogOutputValue = map[string]LogOutput{
	"stdout": LogOutputStdout,
	"stderr": LogOutputStderr,
}

// ParseLogOutput attempts to convert a string to a LogOutput.
func ParseLogOutput(name string) (LogOutput, error) {
	if x, ok := _LogOutputValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _LogOutputValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return LogOutput(""), fmt.Errorf("%s is %w", name, ErrInvalidLogOutput)
}

// MarshalText implements the text marshaller method.
func (x LogOutput) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LogOutput) UnmarshalText(text []byte) error {
	tmp, err := ParseLogOutput(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errLogOutputNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *LogOutput) Scan(value interface{}) (err error) {
	if value == nil {
		*x = LogOutput("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseLogOutput(v)
	case []byte:
		*x, err = ParseLogOutput(string(v))
	case LogOutput:
		*x = v
	case *LogOutput:
		if v == nil {
			return errLogOutputNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errLogOutputNilPtr
		}
		*x, err = ParseLogOutput(*v)
	default:
		return errors.New("invalid type for LogOutput")
	}

	return
}

// Value implements the driver Valuer interface.
func (x LogOutput) Value() (driver.Value, error) {
	return x.String(), nil
}
